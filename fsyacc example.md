# fsyacc example

This example is Dragon book fig 4-59 example `expr.fsyacc`.

build a xUnit project, and install NuGet packages:

```nuget
install-package FslexFsyacc
```

## Token

define the Token type of arithmetic expression.

```F#
type Token =
| Number of float
| LParen
| RParen
| Plus
| Hyphen
| Asterisk
| Slash
```

Tokenizer for expressions using regular expressions

```F#
// install-package FSharp.Idioms to use Perfix and PerfixChar
open FSharp.Idioms.StringOps

let tokenize(inp:string) =
    let rec loop (inp:string) =
        seq {
            match inp with
            | "" -> ()

            | Prefix @"\s+" (_, rest) ->
                yield! loop rest

            | Prefix @"\d+(\.\d+)?" (lexeme, rest) ->
                yield Number <| System.Double.Parse(lexeme)
                yield! loop rest

            | PrefixChar '(' rest ->
                yield LParen
                yield! loop rest

            | PrefixChar ')' rest ->
                yield RParen
                yield! loop rest

            | PrefixChar '+' rest ->
                yield Plus
                yield! loop rest

            | PrefixChar '-' rest ->
                yield Hyphen
                yield! loop rest

            | PrefixChar '*' rest ->
                yield Asterisk
                yield! loop rest

            | PrefixChar '/' rest ->
                yield Slash
                yield! loop rest

            | never -> failwith never
        }

    loop inp
```

fsyacc needs you to provide two functions `getTag` and `getLexeme` to map to the appropriate token from input token sequence.

```F#
let getTag = function
| NUMBER _ -> "NUMBER"
| LPAREN   -> "("
| RPAREN   -> ")"
| PLUS     -> "+"
| MINUS   -> "-"
| STAR -> "*"
| DIV    -> "/"

let getLexeme = function
| NUMBER n -> box n
| _   -> null
```

fsyacc input file:

```fsyacc
%{
open Expr.ExprToken
%}
expr : expr "+" expr         { s0 + s2 }
     | expr "-" expr         { s0 - s2 }
     | expr "*" expr         { s0 * s2 }
     | expr "/" expr         { s0 / s2 }
     | "(" expr ")"          { s1 }
     | "-" expr %prec UMINUS { -s1 }
     | NUMBER                { s0 }
%%
%left "+" "-"
%left "*" "/"
%right UMINUS
%%
NUMBER "float";
expr   "float"
```

We use unit test methods to generate parsing functions:

```F#
[<Fact(Skip="once for all!")>] // 
member this.``1 - fsyacc generateParseTable``() =
    let name = "ExprParseTable"
    let moduleName = $"Expr.{name}"

    //解析表数据
    let fsharpCode = parseTbl.generateParseTable(moduleName)

    let outputDir = Path.Combine(__SOURCE_DIRECTORY__, $"{name}.fs")
    File.WriteAllText(outputDir,fsharpCode)
    output.WriteLine("output yacc:"+outputDir)
```

Include the generated `ExprParseTable.fs` module into the project. The `ExprParseTable.parse` function is generated by the fsyacc file and we can use it directly.

```F#
    let compile (inp:string) =
        inp
        |> ExprToken.tokenize
        |> ExprParseTable.parse
```

We test it to see if it works properly.

```F#
        let inp = "2 + 3 * 5"
        let y = compile inp
        //show result
        Should.equal y 17.0
```

%{
open FslexFsyacc.Lex
open FslexFsyacc.Fslex.FslexToken
%}

file       : HEADER definitions "%%" rules {s0,List.rev s1,List.rev s3}
           | HEADER rules                  {s0,[],List.rev s1}

definitions: definitions definition {s1::s0}
           | definition             {[s0]}

definition : ID "=" expr "\n" {s0,s2}

rules      : rules "\n" rule  {s2::s0}
           | rule             {[s0]}

rule       : expr "/" expr  SEMANTIC  {[s0;s2],s3}
           | expr           SEMANTIC  {[s0],s1}

expr       : character          {s0}
           | expr "|" expr      {Uion(s0,s2)}
           | expr "&" expr      {Concat(s0,s2)}
           | expr "*"           {Natural s0}
           | expr "+"           {Positive s0}
           | expr "?"           {Maybe s0}
           | "(" expr ")"       {s1}
           | HOLE               {Hole s0}
           | "[" characters "]" {s1 |> List.rev |> List.reduce(fun a b -> Uion(a,b))}

character  : ID          {Character s0}
           | QUOTE       {Character s0}

characters : characters "&" character {s2::s0}
           | character                {[s0]}

%%

%left     "|"
%left     "&"
%nonassoc "*" "+" "?"

%%

HEADER      "string";
ID          "string";
QUOTE       "string";
SEMANTIC    "string";
HOLE        "string";
character   "RegularExpression<string>";
characters  "RegularExpression<string> list";
definition  "string*RegularExpression<string>";
definitions "(string*RegularExpression<string>)list";
expr        "RegularExpression<string>";
file        "string*(string*RegularExpression<string>)list*(RegularExpression<string>list*string)list";
rule        "RegularExpression<string>list*string";
rules       "(RegularExpression<string>list*string)list";


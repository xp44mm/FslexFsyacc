# Syntax Analysis 算法汇总

算法：查找语法中所有的可空符号

1. 如果有产生式$A \to \epsilon$，则A是可空的。
2. 终结符是不可空的，可空符号一定是非终结符。
3. 产生式$A \to ... $包括终结符，则此产生式一定是非空的。
4. 删除产生式体中的可空符号，不影响对产生式是否为空的判断。
5. 不断应用上述规则，如果剩余产生式不再变化，则说明找到所有可空符号。

算法：集合等价原理

互相包含的集合等价。如果集合$ABC...$等价，则$A=B=C=...=A \cup B \cup C \cup ...$

算法：根据集合所属关系扩充元素

已知：

1. Map查询表，包含已知元素。
2. 表示所属关系的集合$B\subset A $，组成$(A,B)$对的列表。

求解：

1. 验证查询表已有集合的完整性。查询表Map的某键值K不在超集内$K \notin A $，则Map(K)集合是完整的集合。因为不会再向Map(K)集合中添加元素。
2. 对于列表中每一个完整的子集B并入对应的超集A中。丢弃该项数据。
3. 循环，直到没有子集可以并入超集中。
4. 如果列表为空，则返回查询表
5. 如果列表仍有剩余且子集等价超集$A = B$，则剩余的每个对代表等价的集合。将其合并为一个或多个不相交的集合，运用集合等价原理求等价集合的并集，补齐剩余的元素，然后，返回查询表。

算法：文法符号的FIRST(X)集合

已知：

1. 文法
2. 非终端符号的可空性

求解：

1. 如果X是一个终结符号，那么$FIRST(X) =  X  $
2. 对于每个产生式$X \to Y_1 Y_2 ... Y_n $，找出所有的最左符号(leftmost)。如果$Y_i $是第一个非空符号，则所有最左符号为$Y_1 Y_2 ... Y_i $，如果产生式体都是非空符号，则所有符号$Y_1 Y_2 ... Y_n $都是打头符号。对于每个最左符号$FIRST(Y) \subset FIRST(X) $。
3. 根据集合所属关系填充集合。

算法：计算任何串$Y_1 Y_2 ... Y_n$的FIRST集合

1. 找出串$Y_1 Y_2 ... Y_n$所有的打头符号$Y_1 Y_2 ... Y_i$。
2. $FIRST( Y_1 Y_2 ... Y_n ) = FIRST(Y_1)\cup FIRST(Y_2) \cup ... \cup FIRST(Y_i) $ 

算法：非终端符号的FOLLOW(A)集合

已知：

1. 文法
2. 非终端符号的可空性
3. 文法符号的FISRT集合

求解：

1. 将\$放到FOLLOW(S)中，其中S是开始符号，而\$是输入右端的结束标记。
2. 对于每个产生式$A \to ...B \beta$体中所有的非终端符号B，以及其所跟随的文法符号串$\beta $，串的长度大于零。$FIRST(\beta)\subset FOLLOW(B) $
3. 找出产生式$A \to B_n ... B_2 B_1 $的所有最右符号(rightmost)，最右符号的定义类似于最左符号，只是从产生式末尾开始计算，且最右符号一定是非终端符号。对于每个最右符号$FOLLOW(A) \sub FOLLOW(B) $
4. 根据集合所属关系填充集合。

### 詞法分析器實現

1. 正則表達式，是一個識別器，測試輸入是否符合模式。
2. 正則表達式翻譯成NFA，這個NFA有一個開始狀態，一個接受狀態。最小值狀態是開始狀態，最大值是接受狀態。
3. 向前看操作符，串聯組合兩個正則表達式NFA，除了開始狀態，和接受狀態，串聯組合成的NFA還有一個重要狀態，詞素狀態，他是第一個NFA的接受狀態。
4. Lex并聯組合各個模式，組合成一個大的NFA。
5. 并聯組合的NFA轉換成DFA，一個NFA接受狀態，對應DFA的一個狀態集合。

模擬：

1. DFA的模擬，從狀態0開始，用讀入的字符，根據DFA轉換表查找下一狀態，直到找不到下一狀態爲止。死狀態。
2. DFA從死狀態退著找到第一個接受狀態。
3. 接受狀態如果有詞素狀態，退著找詞素狀態。
4. 返回接受狀態，和詞素，從詞素位置開始重複下一個詞素查找過程。

性能優化：

1. 狀態數目可以壓縮。
2. 連續的字符類會產生連續的目標狀態。可以用這個性質節省内存空間。查詢就不是一對一，要複雜一點。
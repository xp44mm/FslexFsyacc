编译原理：

第一级解析，充分利用现代库成熟的功能，包括正则表达式和字符串操作函数。而非使用yacc的lex分析器。将字符分组，并确定每组的类型。

第二级，对第一级的结果，非嵌套的进行DFA分组。正则表达式应用于token type。

编译过程分为4部：

1. 用正则表达式
2. 用lex
3. 用yacc

正则表达式的运算是一元，二元。没有多元的。

正则表达式->NFA->DFA

NFA由正则表达式转换而成，可以叫做正则NFA，他有如下特点：

状态号是自然数。

状态号由小到大，且连续。

只有一个开始状态，只有一个接受状态。

正则NFA的开始状态是零，接受状态是最大数值。

根据状态的规模，无符号32位整数足够包括所有状态。

开始状态，输入字符，结束状态。组成三元组表示一条边，此三元组的值是唯一的，在NFA表中不重复。

边与边的先后顺序无关紧要。

NFA表是个Set集合。其中每元素是一条边。

正则NFA至少有一条边。至少两个节点。至少一个字符。

NFA先行结合，再结合后的每一行结合，最后整个词法分析器的NFA。

DFA死状态一定是一个线段的终点，不可能是起点。

本算法无需DFA死状态。

文法，产生式的各种性质：

增广语法的新开始符号为`String.empty`。

用记录类型替代类类型。

kernel -> closure的算法带向前看符号

状态，语法符号，

LR表先假设其存在冲突，为歧义表。至少1个查询值，一个以上的查询值，则用优先级排除。

用集合中的索引号代表记录。

kernel的向前看符号，当作为索引时，省略向前看符号集合。当进行`closure`，`goto`推导时应该带上向前看符号。

查询表的值为元素的集合表示歧义表，查询值为普通元素的为确定表。确定表是歧义表的特殊情况，歧义值的集合中有且只有一个元素值。





lexical analyzer由lex生成

yacc parser 由 yacc生成



In Yacc, an empty alternative, as the third line is, denotes $\epsilon$.

a follow b -> ba

a followed by b -> ab

语义动作是生成一个语法树。







冲突中的产生式，和终结符号才需要列出优先级。优先级相对比较大小，绝对值无意义。



# yacc文件说明：

区分大小写。

空白匹配正则表达式`\s+`将被忽略，不放入结果序列。

多行注释同C语言语法`/* .*? */`，不可以嵌套。将被忽略，不放入结果序列。

不支持单行注释。

语法符号字面量，为JSON字符串字面量，双引号包围。语法符号不可以为空字符串`""`，这个是增广语法的开始符号。

当语法符号匹配正则表达式`\w+`时，可以省略包围的引号。

> 由于yacc仅有字符串类型，用以表示语法符号，或者产生式的名称。所以你甚至可以使用数字为符号的名称，而不必用双引号包围之。但是推荐使用大多数语言的名称规范。

顶部第一个产生式头是开始符号。

优先级：高优先级数值更大，先于低优先级计算。比如乘号优先级高于加号。一元运算符优先级高于二元运算符，二元运算符优先级高于三元运算符。

优先级数值可以看作为一个列表字面量，最顶部行的优先级数值最小。

所有冲突都要显式明确的给出规则解决，不会静默解决。

优先级可以解决移动/归纳冲突，不能解决其他冲突，如果出现其他类型的冲突，需要修改语法。需要修改语法来避免r/r冲突的例子：

`ls(0)`是函数调用还是数组的索引？修改语法：ls(0)表示函数调用；ls[0]表示数组索引。

`sum(1,2,,)`参数可以为空的情况？修改语法：参数不可为空加一个占位符。`sum(1,2,_,_)`

